<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Game Th·∫ª B√†i 1‚Äì10 (Online Room)</title>
  <style>
    :root{
      --bg:#0b1020; --text:#e9edff; --muted:#aab3d6;
      --line:rgba(255,255,255,.12); --card:rgba(255,255,255,.08);
      --good:rgba(61,220,151,.18); --warn:rgba(255,209,102,.18); --bad:rgba(255,107,107,.18);
      --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:
        radial-gradient(1000px 700px at 15% 10%, rgba(120,170,255,.18), transparent 55%),
        radial-gradient(900px 700px at 85% 90%, rgba(61,220,151,.14), transparent 55%),
        var(--bg);
      min-height:100vh;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:14px;display:grid;gap:14px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:var(--radius);backdrop-filter:blur(10px);overflow:hidden}
    header{padding:12px 14px;border-bottom:1px solid var(--line);display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
    header h1{margin:0;font-size:14px;letter-spacing:.2px}
    header .sub{font-size:12px;color:var(--muted)}
    .content{padding:14px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:14px}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr} }
    label{font-size:12px;color:var(--muted);display:block;margin:0 0 6px}
    input, select{
      padding:10px 12px;border-radius:12px;border:1px solid var(--line);
      background:rgba(0,0,0,.22);color:var(--text);outline:none;
    }
    input:focus, select:focus{border-color:rgba(120,170,255,.35);box-shadow:0 0 0 4px rgba(120,170,255,.12)}
    button{
      border:1px solid var(--line);background:rgba(255,255,255,.06);color:var(--text);
      padding:10px 12px;border-radius:12px;font-weight:800;cursor:pointer;
    }
    button:disabled{opacity:.55;cursor:not-allowed}
    .primary{border-color:rgba(120,170,255,.35);background:rgba(120,170,255,.14)}
    .good{border-color:rgba(61,220,151,.35);background:rgba(61,220,151,.14)}
    .warn{border-color:rgba(255,209,102,.35);background:rgba(255,209,102,.14)}
    .danger{border-color:rgba(255,107,107,.35);background:rgba(255,107,107,.14)}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:7px 10px;border-radius:999px;border:1px solid var(--line);background:rgba(0,0,0,.18);font-size:12px;color:var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .split{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media (max-width:700px){ .split{grid-template-columns:1fr} }

    .players{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
    @media (max-width: 820px){ .players{grid-template-columns:1fr} }
    .p{border:1px solid var(--line);border-radius:14px;background:rgba(0,0,0,.18);padding:10px;display:grid;gap:6px}
    .pTop{display:flex;justify-content:space-between;gap:10px;align-items:center}
    .pName{font-weight:900}
    .pMeta{font-size:12px;color:var(--muted);display:flex;gap:10px;flex-wrap:wrap}
    .tag{font-size:11px;padding:4px 8px;border-radius:999px;border:1px solid var(--line);background:rgba(255,255,255,.06);color:var(--muted)}
    .tag.host{border-color:rgba(120,170,255,.35);background:rgba(120,170,255,.14);color:var(--text)}
    .tag.turn{border-color:rgba(255,209,102,.35);background:rgba(255,209,102,.14);color:var(--text)}
    .tag.fold{border-color:rgba(255,107,107,.35);background:rgba(255,107,107,.14);color:var(--text)}
    .tag.bot{border-color:rgba(61,220,151,.35);background:rgba(61,220,151,.14);color:var(--text)}

    .hand{display:grid;grid-template-columns:repeat(10,minmax(0,1fr));gap:8px}
    @media (max-width: 980px){ .hand{grid-template-columns:repeat(5,minmax(0,1fr))} }
    .card{
      user-select:none; cursor:pointer;
      border:1px solid var(--line); border-radius:14px;
      background:linear-gradient(135deg, rgba(255,255,255,.10), rgba(0,0,0,.10));
      padding:10px; min-height:56px; display:grid; place-items:center;
      position:relative; overflow:hidden;
    }
    .card .v{font-weight:1000;font-size:18px}
    .card .s{position:absolute;left:10px;top:8px;font-size:11px;color:var(--muted)}
    .card.sel{outline:3px solid rgba(120,170,255,.35)}
    .card.done{opacity:.35;cursor:not-allowed}
    .pickInfo{font-size:12px;color:var(--muted);line-height:1.4}

    pre{margin:0;white-space:pre-wrap;word-break:break-word;background:rgba(0,0,0,.22);border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:12px;min-height:180px;line-height:1.35}
  </style>
</head>
<body>
<div class="wrap">

  <div class="panel">
    <header>
      <div>
        <h1>Game th·∫ª b√†i 1‚Äì10 (Online Room)</h1>
        <div class="sub">Online room ‚Ä¢ t·ªëi ƒëa 10 ng∆∞·ªùi ‚Ä¢ c√≥ bot ‚Ä¢ host-authoritative (demo)</div>
      </div>
      <div class="row">
        <span class="pill">Domain: <span class="mono" id="dom"></span></span>
        <span class="pill">WS: <span class="mono" id="wsurl"></span></span>
        <span class="pill" id="connPill">DISCONNECTED</span>
      </div>
    </header>

    <div class="content">
      <div class="split">
        <div>
          <label>M√£ ph√≤ng (room)</label>
          <input id="room" value="abc123" maxlength="24">
        </div>
        <div>
          <label>T√™n c·ªßa b·∫°n</label>
          <input id="name" value="Nhanh" maxlength="18">
        </div>
      </div>

      <div class="split" style="margin-top:10px">
        <div>
          <label>S·ªë ti·ªÅn ban ƒë·∫ßu (l∆∞u local)</label>
          <input id="money" type="number" value="1000" min="0" step="50">
        </div>
        <div>
          <label>Ch·∫ø ƒë·ªô</label>
          <select id="mode">
            <option value="online">Online (WS)</option>
            <option value="solo">Ch∆°i v·ªõi m√°y (offline)</option>
          </select>
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <button class="good" id="connect">Connect</button>
        <button class="danger" id="disconnect" disabled>Disconnect</button>
        <button class="warn" id="copyLink">Copy link ph√≤ng</button>
        <span class="pill">B·∫°n: <span class="mono" id="meId">-</span></span>
        <span class="pill">Ch·ªß ph√≤ng: <span class="mono" id="hostId">-</span></span>
      </div>

      <div class="pickInfo" style="margin-top:10px">
        Ch·ªçn 2 l√°: 1 l√° <b>B√≠ m·∫≠t</b> (b·∫°n bi·∫øt), 1 l√° <b>C√¥ng khai</b> (ng∆∞·ªùi kh√°c bi·∫øt, b·∫°n kh√¥ng bi·∫øt ‚Üí ‚Äú??‚Äù).
      </div>
    </div>
  </div>

  <div class="grid">
    <div class="panel">
      <header>
        <div>
          <h1>B√†n ch∆°i</h1>
          <div class="sub" id="phaseSub">Tr·∫°ng th√°i: -</div>
        </div>
        <div class="row">
          <span class="pill">Pot: <span class="mono" id="pot">0</span></span>
          <span class="pill">C∆∞·ª£c hi·ªán t·∫°i: <span class="mono" id="curBet">0</span></span>
          <span class="pill">V√≤ng: <span class="mono" id="round">0</span>/5</span>
        </div>
      </header>

      <div class="content">
        <div class="row" style="justify-content:space-between">
          <div class="row">
            <button class="primary" id="startBtn" disabled>START</button>
            <button class="warn" id="resetGameBtn" disabled>Reset game</button>
          </div>

          <div class="row" id="hostControls" style="display:none">
            <span class="pill">Host settings</span>
            <label style="margin:0;color:var(--muted);font-size:12px">Max</label>
            <select id="maxPlayers">
              <option>2</option><option>3</option><option>4</option><option>5</option>
              <option>6</option><option>7</option><option>8</option><option>9</option>
              <option selected>10</option>
            </select>
            <label style="margin:0;color:var(--muted);font-size:12px">Bots</label>
            <select id="botCount">
              <option selected>0</option><option>1</option><option>2</option><option>3</option>
              <option>4</option><option>5</option><option>6</option><option>7</option><option>8</option>
            </select>
            <button class="good" id="applyHost">√Åp d·ª•ng</button>
          </div>
        </div>

        <div style="height:12px"></div>
        <div class="players" id="players"></div>

        <div style="height:12px"></div>

        <div class="panel" style="border-radius:14px">
          <header>
            <div>
              <h1>L√° c·ªßa b·∫°n (10 l√° √∫p)</h1>
              <div class="sub">5 v√≤ng, m·ªói v√≤ng ch·ªçn 2 l√°. ƒêi·ªÉm = t·ªïng c√°c l√° ƒë√£ reveal.</div>
            </div>
            <div class="row">
              <span class="pill">ƒêi·ªÉm: <span class="mono" id="myScore">0</span></span>
              <span class="pill">C√≤n: <span class="mono" id="myLeft">10</span></span>
              <span class="pill">Ch·ªçn: <span class="mono" id="selInfo">0/2</span></span>
            </div>
          </header>
          <div class="content">
            <div class="hand" id="hand"></div>

            <div style="height:10px"></div>
            <div class="row">
              <label style="margin:0;color:var(--muted);font-size:12px">Trong 2 l√°, l√° n√†o l√† ‚ÄúB√≠ m·∫≠t‚Äù?</label>
              <select id="secretWhich">
                <option value="0">L√° ch·ªçn #1</option>
                <option value="1">L√° ch·ªçn #2</option>
              </select>
              <button class="good" id="confirmPick" disabled>X√°c nh·∫≠n ch·ªçn 2 l√°</button>
            </div>

            <div style="height:10px"></div>
            <div class="row">
              <button class="good" id="callBtn" disabled>THEO</button>
              <button class="danger" id="foldBtn" disabled>B·ªé</button>
              <input id="raiseAmt" type="number" value="50" min="1" step="10" style="width:140px">
              <button class="warn" id="raiseBtn" disabled>C∆Ø·ª¢C TH√äM</button>
            </div>

            <div class="pickInfo" id="hintBox" style="margin-top:10px"></div>
          </div>
        </div>

      </div>
    </div>

    <div class="panel">
      <header>
        <div>
          <h1>Log</h1>
          <div class="sub">Host s·∫Ω t·ª± ƒëi·ªÅu khi·ªÉn bot.</div>
        </div>
        <div class="row">
          <button class="warn" id="clearLog">Clear</button>
          <button id="sendPing" disabled>Send ping</button>
        </div>
      </header>
      <div class="content">
        <pre id="log"></pre>
      </div>
    </div>
  </div>

</div>

<script>
(() => {
  // ===== Helpers =====
  const $ = (id)=>document.getElementById(id);
  const logEl = $("log");
  const log = (m)=>{ const t=new Date().toLocaleTimeString(); logEl.textContent += `[${t}] ${m}\n`; logEl.scrollTop=logEl.scrollHeight; };

  const proto = location.protocol === "https:" ? "wss" : "ws";
  $("dom").textContent = location.host;

  const qs = new URLSearchParams(location.search);
  if (qs.get("room")) $("room").value = qs.get("room");
  if (qs.get("name")) $("name").value = qs.get("name");

  function wsUrl(room,name){
    return `${proto}://${location.host}/ws?room=${encodeURIComponent(room)}&name=${encodeURIComponent(name)}`;
  }
  function uid(){ return (crypto?.randomUUID?.() || (Date.now()+"-"+Math.random())).toString(); }
  function randCard(){ return 1 + Math.floor(Math.random()*10); }
  function shuffle(a){
    for (let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }
  function escapeHtml(str){
    return String(str).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  // ===== Client =====
  let ws = null;
  let mode = "online";
  const ME = { id: uid(), name:"", money:1000, isBot:false };

  // ===== State (host authoritative) =====
  let state = null;
  let isHost = false;
  let selected = [];

  // ===== UI =====
  const connPill = $("connPill");
  const connectBtn = $("connect");
  const disconnectBtn = $("disconnect");
  const sendPingBtn = $("sendPing");
  const copyLinkBtn = $("copyLink");

  const startBtn = $("startBtn");
  const resetGameBtn = $("resetGameBtn");
  const hostControls = $("hostControls");
  const applyHostBtn = $("applyHost");
  const maxPlayersSel = $("maxPlayers");
  const botCountSel = $("botCount");

  const playersEl = $("players");
  const handEl = $("hand");
  const confirmPickBtn = $("confirmPick");
  const secretWhichSel = $("secretWhich");
  const selInfo = $("selInfo");
  const hintBox = $("hintBox");

  const callBtn = $("callBtn");
  const foldBtn = $("foldBtn");
  const raiseAmt = $("raiseAmt");
  const raiseBtn = $("raiseBtn");

  const hostIdEl = $("hostId");
  const meIdEl = $("meId");
  const phaseSub = $("phaseSub");
  const potEl = $("pot");
  const curBetEl = $("curBet");
  const roundEl = $("round");
  const myScoreEl = $("myScore");
  const myLeftEl = $("myLeft");

  $("clearLog").onclick = ()=> logEl.textContent="";
  sendPingBtn.onclick = ()=> send({type:"ping", t:Date.now()});

  copyLinkBtn.onclick = async ()=>{
    const room = ($("room").value.trim()||"lobby").toLowerCase();
    const name = ($("name").value.trim()||"Player");
    const u = new URL(location.href);
    u.searchParams.set("room", room);
    u.searchParams.set("name", name);
    try{ await navigator.clipboard.writeText(u.toString()); log("Copied link ph√≤ng."); }
    catch{ prompt("Copy link:", u.toString()); }
  };

  function setConn(on){
    connPill.textContent = on ? "CONNECTED" : "DISCONNECTED";
    connPill.style.borderColor = on ? "rgba(61,220,151,.35)" : "rgba(255,255,255,.12)";
    connPill.style.background = on ? "rgba(61,220,151,.14)" : "rgba(0,0,0,.18)";
    connectBtn.disabled = on;
    disconnectBtn.disabled = !on;
    sendPingBtn.disabled = !on;
  }

  // ===== Protocol =====
  function send(obj){
    if (mode==="solo") return onLocalMessage(obj);
    if (!ws || ws.readyState!==1) return;
    ws.send(JSON.stringify(obj));
  }

  // ===== Engine =====
  function makeEmptyState(room){
    return {
      v: 3,
      room,
      hostId: null,
      maxPlayers: 10,
      botCount: 0,
      phase: "lobby", // lobby | picking | betting
      round: 0,
      pot: 0,
      currentBet: 0,
      turnIndex: 0,
      players: {},
      order: [],
      picksDone: {},
      bet: {},
      folded: {},
      lastAction: ""
    };
  }

  function addPlayerToState(st, p){
    if (st.players[p.id]) return;
    st.players[p.id] = {
      id: p.id,
      name: p.name,
      money: p.money,
      isBot: !!p.isBot,
      hand: Array(10).fill(null).map(()=>({v: randCard(), used:false})),
      reveals: [],
      publicSeenByOthers: null,
      secretKnownBySelf: null,
      score: 0
    };
    st.order.push(p.id);
  }

  function ensureHost(st){
    if (st.hostId && st.players[st.hostId]) return;
    st.hostId = st.order[0] || null;
  }

  function hostSet(st, maxPlayers, botCount){
    st.maxPlayers = Math.max(2, Math.min(10, maxPlayers|0));
    st.botCount = Math.max(0, Math.min(10, botCount|0));
  }

  function maybeFillBots(st){
    const humans = st.order.filter(id=>!st.players[id].isBot).length;
    const desiredTotal = Math.min(st.maxPlayers, humans + st.botCount);
    const currentTotal = st.order.length;
    const need = Math.max(0, desiredTotal - currentTotal);
    for (let i=0;i<need;i++){
      const bid = "BOT-"+uid().slice(0,8);
      addPlayerToState(st, {id:bid, name:"Bot"+(i+1), money: 1000, isBot:true});
    }
    ensureHost(st);
  }

  function startGame(st){
    st.phase = "picking";
    st.round = 1;
    st.pot = 0;
    st.currentBet = 0;
    st.turnIndex = 0;
    st.picksDone = {};
    st.bet = {};
    st.folded = {};
    st.lastAction = "Game started";
    for (const id of st.order){
      const pl = st.players[id];
      pl.hand = Array(10).fill(null).map(()=>({v: randCard(), used:false}));
      pl.reveals = [];
      pl.publicSeenByOthers = null;
      pl.secretKnownBySelf = null;
      pl.score = 0;
    }
  }

  function nextTurn(st){
    const n = st.order.length;
    for (let k=1;k<=n;k++){
      const idx = (st.turnIndex + k) % n;
      const id = st.order[idx];
      if (!st.folded[id]) { st.turnIndex = idx; return; }
    }
  }

  function allPicked(st){
    for (const id of st.order){
      if (st.folded[id]) continue;
      if (!st.picksDone[id]) return false;
    }
    return true;
  }

  function beginBetting(st){
    st.phase = "betting";
    st.currentBet = 0;
    st.bet = {};
    st.folded = {};
    st.turnIndex = 0;
    st.lastAction = "Betting started";
  }

  function allBetsSettled(st){
    for (const id of st.order){
      if (st.folded[id]) continue;
      const b = st.bet[id] || 0;
      if (b !== st.currentBet) return false;
    }
    return true;
  }

  function showdown(st){
    st.lastAction = "Showdown!";
    let best = -1, winners=[];
    for (const id of st.order){
      if (st.folded[id]) continue;
      const sc = st.players[id].score;
      if (sc > best){ best = sc; winners=[id]; }
      else if (sc === best){ winners.push(id); }
    }
    if (winners.length === 0){
      st.lastAction = "No winner (all folded)";
    } else {
      const share = Math.floor(st.pot / winners.length);
      for (const id of winners) st.players[id].money += share;
      st.lastAction = winners.length===1
        ? `${st.players[winners[0]].name} ƒÉn pot`
        : `H√≤a chia pot: ${winners.map(id=>st.players[id].name).join(", ")}`;
    }
    st.pot = 0;
    st.currentBet = 0;

    if (st.round >= 5){
      st.phase = "lobby";
      st.lastAction += " ‚Ä¢ END (Host c√≥ th·ªÉ START l·∫°i)";
      return;
    }

    st.round += 1;
    st.phase = "picking";
    st.picksDone = {};
    st.bet = {};
    st.folded = {};
    st.turnIndex = 0;
  }

  function handlePick(st, id, picks, secretWhich){
    const pl = st.players[id];
    if (!pl) return false;
    if (st.phase !== "picking") return false;
    if (st.picksDone[id]) return false;
    if (!Array.isArray(picks) || picks.length!==2) return false;

    const a = picks[0]|0, b = picks[1]|0;
    if (a===b) return false;

    const ha = pl.hand[a], hb = pl.hand[b];
    if (!ha || !hb || ha.used || hb.used) return false;

    ha.used = true; hb.used = true;

    const secretIdx = (secretWhich===1) ? b : a;
    const publicIdx = (secretWhich===1) ? a : b;

    const secretV = pl.hand[secretIdx].v;
    const publicV = pl.hand[publicIdx].v;

    pl.reveals.push({ secretV, publicV });
    pl.score = pl.reveals.reduce((s,r)=>s + r.secretV + r.publicV, 0);

    pl.secretKnownBySelf = secretV;
    pl.publicSeenByOthers = publicV;

    st.picksDone[id] = true;
    st.lastAction = `${pl.name} picked`;

    if (allPicked(st)) beginBetting(st);
    return true;
  }

  function handleBet(st, id, action, amount){
    if (st.phase !== "betting") return false;
    const pl = st.players[id];
    if (!pl) return false;
    if (st.folded[id]) return false;

    const turnId = st.order[st.turnIndex];
    if (turnId !== id) return false;

    const myBet = st.bet[id] || 0;

    if (action === "fold"){
      st.folded[id] = true;
      st.lastAction = `${pl.name} FOLD`;
      const active = st.order.filter(pid=>!st.folded[pid]);
      if (active.length === 1){
        const winner = st.players[active[0]];
        winner.money += st.pot;
        st.pot = 0;
        st.lastAction = `${winner.name} WIN (all folded)`;
        if (st.round >= 5) st.phase="lobby";
        else { st.round += 1; st.phase="picking"; st.picksDone={}; st.bet={}; st.folded={}; st.turnIndex=0; }
      } else {
        nextTurn(st);
      }
      return true;
    }

    if (action === "call"){
      const need = Math.max(0, st.currentBet - myBet);
      const pay = Math.min(need, pl.money);
      pl.money -= pay;
      st.bet[id] = myBet + pay;
      st.pot += pay;
      st.lastAction = `${pl.name} CALL (+${pay})`;
      nextTurn(st);
      if (allBetsSettled(st)) showdown(st);
      return true;
    }

    if (action === "raise"){
      const raiseBy = Math.max(1, (amount|0));
      const needToCall = Math.max(0, st.currentBet - myBet);
      const totalNeed = needToCall + raiseBy;
      const pay = Math.min(totalNeed, pl.money);
      pl.money -= pay;
      const newBet = myBet + pay;
      st.bet[id] = newBet;
      st.pot += pay;
      if (newBet > st.currentBet) st.currentBet = newBet;
      st.lastAction = `${pl.name} RAISE (+${pay})`;
      nextTurn(st);
      return true;
    }
    return false;
  }

  // ===== BOT AI (FIX CH√çNH N·∫∞M ·ªû ƒê√ÇY) =====
  function botPickIfNeeded(st){
    if (st.phase !== "picking") return false;
    let acted = false;

    for (const id of st.order){
      const pl = st.players[id];
      if (!pl || !pl.isBot) continue;
      if (st.picksDone[id]) continue;

      const avail = [];
      for (let i=0;i<pl.hand.length;i++){
        if (!pl.hand[i].used) avail.push(i);
      }
      if (avail.length < 2){
        st.picksDone[id] = true;
        continue;
      }

      shuffle(avail);
      const picks = [avail[0], avail[1]];
      const secretWhich = Math.random() < 0.5 ? 0 : 1;
      const ok = handlePick(st, id, picks, secretWhich);
      if (ok) acted = true;
    }
    return acted;
  }

  function botBetIfTurn(st){
    if (st.phase !== "betting") return false;
    const turnId = st.order[st.turnIndex];
    const pl = st.players[turnId];
    if (!pl || !pl.isBot || st.folded[turnId]) return false;

    const myBet = st.bet[turnId] || 0;
    const need = Math.max(0, st.currentBet - myBet);

    // heuristic ƒë∆°n gi·∫£n
    if (need > pl.money * 0.6 && Math.random() < 0.5){
      return handleBet(st, turnId, "fold");
    }
    if (Math.random() < 0.22 && pl.money > need + 30){
      return handleBet(st, turnId, "raise", 30 + Math.floor(Math.random()*50));
    }
    return handleBet(st, turnId, "call");
  }

  function pumpBots(st){
    let guard = 80;
    while (guard-- > 0){
      let changed = false;

      // 1) n·∫øu ƒëang picking: bot t·ª± pick
      if (st.phase === "picking"){
        changed = botPickIfNeeded(st);
        if (!changed) break;
        continue;
      }

      // 2) n·∫øu ƒëang betting: bot h√†nh ƒë·ªông theo l∆∞·ª£t
      if (st.phase === "betting"){
        changed = botBetIfTurn(st);
        if (!changed) break;
        continue;
      }

      break;
    }
  }

  // ===== Broadcast =====
  function broadcastState(){
    if (!isHost) return;
    send({type:"state", state});
  }

  // ===== onMessage =====
  function onMessage(msg){
    if (msg.type === "hello") return;
    if (msg.type === "sys") { log("SYS: " + msg.msg); return; }

    if (msg.type === "state"){
      state = msg.state;
      isHost = state?.hostId === ME.id;
      renderAll();
      return;
    }

    if (msg.type === "join"){
      if (!state) return;
      if (!isHost) return;

      if (state.order.length >= state.maxPlayers) {
        state.lastAction = "Room full, join rejected";
      } else {
        addPlayerToState(state, { id: msg.id, name: msg.name, money: msg.money, isBot: !!msg.isBot });
        ensureHost(state);
        maybeFillBots(state);
        state.lastAction = `${msg.name} joined`;
      }
      pumpBots(state);
      broadcastState();
      return;
    }

    if (!state) return;
    if (!isHost) return;

    if (msg.type === "host_set"){
      hostSet(state, msg.maxPlayers, msg.botCount);
      maybeFillBots(state);
      state.lastAction = `Host set max=${state.maxPlayers}, bots=${state.botCount}`;
      pumpBots(state);
      broadcastState();
      return;
    }

    if (msg.type === "start"){
      ensureHost(state);
      maybeFillBots(state);
      startGame(state);
      pumpBots(state);     // <<< bots pick ngay
      broadcastState();
      return;
    }

    if (msg.type === "pick"){
      handlePick(state, msg.id, msg.picks, msg.secretWhich);
      pumpBots(state);
      broadcastState();
      return;
    }

    if (msg.type === "bet"){
      handleBet(state, msg.id, msg.action, msg.amount);
      pumpBots(state);
      broadcastState();
      return;
    }
  }

  // ===== Offline solo =====
  function onLocalMessage(msg){
    onMessage(msg);
    // offline: host t·ª± broadcast -> nh∆∞ng send({type:"state"}) l·∫°i g·ªçi onLocalMessage ti·∫øp => v√≤ng l·∫∑p
    // n√™n ta kh√¥ng d√πng send() broadcast trong offline, m√† g·ªçi render tr·ª±c ti·∫øp ·ªü broadcastState().
  }

  // Override broadcast for offline to avoid recursion
  function broadcastStateOffline(){
    renderAll();
  }

  // ===== UI events =====
  function onCardClick(i){
    if (!state) return;
    if (state.phase !== "picking") return;
    const me = state.players[ME.id];
    if (!me) return;
    if (state.picksDone?.[ME.id]) return;
    if (me.hand[i]?.used) return;

    if (selected.includes(i)) selected = selected.filter(x=>x!==i);
    else {
      if (selected.length >= 2) return;
      selected.push(i);
    }
    renderHand();
  }

  $("confirmPick").onclick = ()=>{
    if (selected.length !== 2) return;
    const secretWhich = parseInt(secretWhichSel.value,10) || 0;

    if (mode==="solo"){
      // offline: tr·ª±c ti·∫øp x·ª≠ l√Ω nh∆∞ host
      handlePick(state, ME.id, [selected[0], selected[1]], secretWhich);
      pumpBots(state);
      renderAll();
      selected = [];
      return;
    }

    send({type:"pick", id:ME.id, picks:[selected[0], selected[1]], secretWhich});
    selected = [];
    renderHand();
  };

  $("callBtn").onclick = ()=>{
    if (mode==="solo"){ handleBet(state, ME.id, "call"); pumpBots(state); renderAll(); return; }
    send({type:"bet", id:ME.id, action:"call"});
  };
  $("foldBtn").onclick = ()=>{
    if (mode==="solo"){ handleBet(state, ME.id, "fold"); pumpBots(state); renderAll(); return; }
    send({type:"bet", id:ME.id, action:"fold"});
  };
  $("raiseBtn").onclick = ()=>{
    const amt = Math.max(1, parseInt($("raiseAmt").value||"1",10) || 1);
    if (mode==="solo"){ handleBet(state, ME.id, "raise", amt); pumpBots(state); renderAll(); return; }
    send({type:"bet", id:ME.id, action:"raise", amount: amt});
  };

  $("applyHost").onclick = ()=>{
    const maxPlayers = parseInt(maxPlayersSel.value,10)||10;
    const botCount = parseInt(botCountSel.value,10)||0;
    if (mode==="solo"){
      hostSet(state, maxPlayers, botCount);
      maybeFillBots(state);
      pumpBots(state);
      renderAll();
      return;
    }
    send({type:"host_set", maxPlayers, botCount});
  };

  $("startBtn").onclick = ()=>{
    if (mode==="solo"){
      maybeFillBots(state);
      startGame(state);
      pumpBots(state);
      renderAll();
      return;
    }
    send({type:"start"});
  };

  $("resetGameBtn").onclick = ()=>{
    if (!state) return;
    state.phase = "lobby";
    state.round = 0;
    state.pot = 0;
    state.currentBet = 0;
    state.picksDone = {};
    state.bet = {};
    state.folded = {};
    state.lastAction = "Reset";
    if (mode==="solo"){ renderAll(); return; }
    if (isHost){ broadcastState(); }
  };

  // ===== Render =====
  function renderAll(){
    hostIdEl.textContent = state?.hostId || "-";
    isHost = !!state && state.hostId === ME.id;
    hostControls.style.display = isHost ? "" : "none";
    $("startBtn").disabled = !(isHost && state && state.order.length >= 2);
    $("resetGameBtn").disabled = !(state);

    phaseSub.textContent = state ? `Tr·∫°ng th√°i: ${state.phase} ‚Ä¢ ${state.lastAction||""}` : "Tr·∫°ng th√°i: -";
    potEl.textContent = state ? String(state.pot) : "0";
    curBetEl.textContent = state ? String(state.currentBet) : "0";
    roundEl.textContent = state ? String(state.round||0) : "0";

    renderPlayers();
    renderHand();
    renderControls();
  }

  function renderPlayers(){
    playersEl.innerHTML = "";
    if (!state){ playersEl.innerHTML = `<div class="pill">Ch∆∞a c√≥ state. H√£y Connect.</div>`; return; }

    for (const id of state.order){
      const pl = state.players[id];
      if (!pl) continue;

      const me = (id === ME.id);
      const tags = [];
      if (id === state.hostId) tags.push(`<span class="tag host">HOST</span>`);
      if (pl.isBot) tags.push(`<span class="tag bot">BOT</span>`);
      if (state.phase==="betting" && state.order[state.turnIndex]===id && !state.folded[id]) tags.push(`<span class="tag turn">TURN</span>`);
      if (state.folded[id]) tags.push(`<span class="tag fold">FOLDED</span>`);

      let publicSeen;
      if (state.phase==="lobby") publicSeen = "-";
      else if (me) publicSeen = pl.publicSeenByOthers==null ? "-" : "??";
      else publicSeen = pl.publicSeenByOthers==null ? "-" : String(pl.publicSeenByOthers);

      let secretKnown;
      if (state.phase==="lobby") secretKnown = "-";
      else if (me) secretKnown = pl.secretKnownBySelf==null ? "-" : String(pl.secretKnownBySelf);
      else secretKnown = pl.secretKnownBySelf==null ? "-" : "üîí";

      const b = state.bet?.[id] || 0;

      const div = document.createElement("div");
      div.className = "p";
      div.innerHTML = `
        <div class="pTop">
          <div class="pName">${escapeHtml(pl.name)} ${me?'<span class="tag">YOU</span>':''}</div>
          <div class="row" style="gap:6px">${tags.join("")}</div>
        </div>
        <div class="pMeta">
          <span>üí∞ <b class="mono">${pl.money}</b></span>
          <span>üéØ Score <b class="mono">${pl.score||0}</b></span>
          <span>üßæ Bet <b class="mono">${b}</b></span>
          <span>üëÅÔ∏è Public <b class="mono">${publicSeen}</b></span>
          <span>ü§´ Secret <b class="mono">${secretKnown}</b></span>
        </div>
      `;
      playersEl.appendChild(div);
    }
  }

  function renderHand(){
    handEl.innerHTML = "";
    selected = selected.filter(i => state?.players?.[ME.id]?.hand?.[i] && !state.players[ME.id].hand[i].used);

    const pl = state?.players?.[ME.id];
    if (!state || !pl){
      handEl.innerHTML = `<div class="pill">Ch∆∞a v√†o ph√≤ng / ch∆∞a c√≥ b√†i.</div>`;
      selInfo.textContent = "0/2";
      confirmPickBtn.disabled = true;
      myScoreEl.textContent = "0";
      myLeftEl.textContent = "10";
      return;
    }

    const left = pl.hand.filter(c=>!c.used).length;
    myLeftEl.textContent = String(left);
    myScoreEl.textContent = String(pl.score||0);

    const pickingAllowed = (state.phase === "picking") && !state.picksDone?.[ME.id];

    for (let i=0;i<pl.hand.length;i++){
      const c = pl.hand[i];
      const div = document.createElement("div");
      div.className = "card";
      if (c.used) div.classList.add("done");
      if (selected.includes(i)) div.classList.add("sel");

      const canClick = pickingAllowed && !c.used;
      div.style.cursor = canClick ? "pointer" : "not-allowed";
      div.onclick = ()=> { if (canClick) onCardClick(i); };

      div.innerHTML = `<div class="s">#${i+1}</div><div class="v">üÇ†</div>`;
      handEl.appendChild(div);
    }

    selInfo.textContent = `${selected.length}/2`;
    confirmPickBtn.disabled = !(state.phase==="picking" && selected.length===2 && !state.picksDone?.[ME.id]);
  }

  function renderControls(){
    hintBox.textContent = "";
    const myTurn = !!state && state.phase==="betting" && state.order[state.turnIndex]===ME.id && !state.folded?.[ME.id];

    $("callBtn").disabled = !(state && myTurn);
    $("foldBtn").disabled = !(state && myTurn);
    $("raiseBtn").disabled = !(state && myTurn);

    if (!state) return;

    if (state.phase === "lobby"){
      hintBox.textContent = "Lobby. Host ch·ªânh Bots r·ªìi START.";
      return;
    }
    if (state.phase === "picking"){
      hintBox.textContent = state.picksDone?.[ME.id]
        ? "B·∫°n ƒë√£ pick xong. Ch·ªù ng∆∞·ªùi kh√°c / bot..."
        : "Ch·ªçn 2 l√° r·ªìi x√°c nh·∫≠n.";
      return;
    }
    if (state.phase === "betting"){
      const myBet = state.bet?.[ME.id] || 0;
      const need = Math.max(0, state.currentBet - myBet);
      hintBox.textContent = myTurn ? `ƒê·∫øn l∆∞·ª£t b·∫°n. C·∫ßn theo th√™m: ${need}` : "ƒêang c∆∞·ª£c...";
    }
  }

  // ===== Connect / Disconnect =====
  function connect(){
    mode = $("mode").value;

    ME.name = ($("name").value.trim() || "Player").slice(0,18);
    ME.money = Math.max(0, parseInt($("money").value||"1000",10) || 1000);
    localStorage.setItem("doublef_money", String(ME.money));
    localStorage.setItem("doublef_name", ME.name);

    meIdEl.textContent = ME.id;

    const room = ($("room").value.trim()||"lobby").toLowerCase();
    const url = wsUrl(room, ME.name);
    $("wsurl").textContent = url;

    if (mode==="solo"){
      setConn(true);
      state = makeEmptyState(room);
      state.hostId = ME.id;
      isHost = true;
      addPlayerToState(state, {id:ME.id, name:ME.name, money:ME.money, isBot:false});
      ensureHost(state);
      renderAll();
      return;
    }

    // host-candidate: ng∆∞·ªùi m·ªü tr∆∞·ªõc s·∫Ω gi·ªØ host ·ªïn
    state = makeEmptyState(room);
    state.hostId = ME.id;
    isHost = true;
    addPlayerToState(state, {id:ME.id, name:ME.name, money:ME.money, isBot:false});
    ensureHost(state);

    ws = new WebSocket(url);
    ws.onopen = ()=>{
      setConn(true);
      log("WS open");
      // host broadcast initial state
      broadcastState();
      // send join
      send({type:"join", id:ME.id, name:ME.name, money:ME.money, isBot:false});
    };
    ws.onmessage = (e)=>{
      try{ onMessage(JSON.parse(e.data)); }
      catch{ log("msg(raw): " + e.data); }
    };
    ws.onclose = ()=>{
      setConn(false);
      log("WS close");
      ws = null;
      state = null;
      isHost = false;
      renderAll();
    };
    ws.onerror = ()=> log("WS error");
  }

  function disconnect(){
    if (mode==="solo"){
      setConn(false);
      state = null;
      isHost = false;
      renderAll();
      return;
    }
    ws?.close();
  }

  connectBtn.onclick = connect;
  disconnectBtn.onclick = disconnect;

  // restore local
  const savedName = localStorage.getItem("doublef_name");
  const savedMoney = localStorage.getItem("doublef_money");
  if (savedName) $("name").value = savedName;
  if (savedMoney) $("money").value = savedMoney;

  setConn(false);
  $("wsurl").textContent = "-";
  renderAll();
})();
</script>
</body>
</html>
